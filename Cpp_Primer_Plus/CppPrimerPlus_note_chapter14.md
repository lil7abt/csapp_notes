# Chapter 14 Reusing Code in C++
## 14.1 Classes with Object Members
## 14.2 Private Inheritance
在这种private遗传下，基类的public和protected方法就变成了派生类的private成员。也就是说基类的函数就不再是派生类对象的public interface. 可以被用，但是只在派生类函数的内部使用。In short, the containment approach uses object names to invoke a method, whereas private inheritance uses the class name and the scope-resolution operator instead.
## 14.3 Multiple Inheritance
 表示一个类有多个直接基类，且遗传基类都必须是public
## 14.4 Class Templates
比较多的是做容器用的类

* Template Specializations: a template decribes a class in terms of a general type, whereas a specialization is a class declaration generated by using a specific type.
  * **Implicit Instantiations**: The compiler doesn't generate an implicit isntantiation of the class until it needs object.
  ```c++
  ArrayTP<double, 30> * pt;//a pointer, no object needed yet
  pt = new ArrayTP<double, 30>; //now an object is needed.
  ```
  The second state ment causes the *compiler to generate a class def* and also an object that is created accordign to that definition.
  * **Explicit Instantiations**: it happens when you declare a class by using the keyword `template` and indicateing the desired type or types. The declaration should be in the same namespace as the template definition.
  ```c++
  template class ArrayTP<string, 100>;//generates ArrayTP<string, 100> class
  ```
  * **Explicit Specialization**: 例如一个sorted array，里面会比较各个数的大小的时候会重载>运算符，如果是int类的class还好说，如果是string类的就不行了，则需要一个特殊的从template实例化来的类，就叫做Explicit Specialization.
  ```c++
  template <> class Classname<specialized-type-name>{...};// standard-form
  template <> class SortedArray<const char *> {...} // an Eg
  SortedArray<int>         scores; //use general definition
  SortedArray<const char*> dates;  //use specialized defintion
  ```
  * **Partial Speicialization**: can provide a specific type for one of the type parameters.
  ```c++
  /*general template*/
  template <class T1, class T2> 
  class Pair {...};
  /*partial-specialization template*/
  template <class T1> 
  class Pair<T1, int> {...};
  /*complete-specialization template*/
  template <>         
  class Pair<int, int> {...};

  Pair<double, int> p1; //use general Pair template
  Pair<double, int> p2; //use partial-specialization Pair template
  Pair<int   , int> P3; //use general Pair template
  ```
  根在template后面的<> 里面含有的是仍然没有specialized的类型参数，所有后面的声明中，T2被设成了int，但是T1还是Open的。注意如果specialize所有的参数的话，会导致第一个<>为空，即达成了一个完整的explicit specialization。
  
## 14.5 Summary
* Public Inheritance: to model is-a relationship
* Private Inheritance : to model has-a relationship; public and protected members of the base-class become *private* members of the derived class
* Protected Inheritance: to model has-a relationship; public and protected members of the base-class become *protected* members of the drived class.
* We can also reuse class code by developing a class with members that are themselves objects. --> containmemtm, layering and composition --> to model the has-a relationship --> simpler
* Multiple Inheritance (MI): protected and private MI models the has-a relationship; public MI models the is-a relationship.
* Class Templates: a generic class design; Class definitions are generated when you declare a class object and specify a particular type.
  ```C++
  template <class T>  //type parameter
  class Ic
  {
      T v;
      ...
  public: 
      Ic(const T & val) : v(val){}
      ...
  };

  class Ic<short> sic;    //implicit instantiation
  template class Ic<int>; //explicit instantiation
  ```